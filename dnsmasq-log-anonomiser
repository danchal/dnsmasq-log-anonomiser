#!/usr/bin/python3
import os, time, sys
import configparser, argparse
import logging

END_ACTIONS = ['cached', 'reply']
ALLOW_IP_ACTIONS = ['query[A]', 'query[AAAA]', 'query[PTR]', 'query[SRV]', 'forwarded']
FINAL_RESPONSE_CONTEXT = 'is'
FLUSH_INTERVAL = 1
DNS_TIMEOUT = 5
FIELD_COUNT = 10

logger = logging.getLogger()
formatter = logging.Formatter('[%(levelname)s][%(module)s.%(funcName)s] %(message)s')
logger.setLevel(logging.INFO)

class Settings:
    conf = {}

    @staticmethod
    def get(name):
        return Settings.conf[name]

    @staticmethod
    def set(name, value):
        Settings.conf[name] = value

def print_log_line(file, fields):
    line = ''
    for f in fields[:FIELD_COUNT]:
        line = line + ' ' + str(f) if line else str(f)
    line = line + '\n'
    file.write(line)

def parse_arguments():
    parser = argparse.ArgumentParser(description='Dnsmasq log anonomiser.')
    parser.add_argument('-c','--config', help='configuration file',required=False, type=str)
    parser.add_argument('-i','--input', help='input dnsmasq log file',required=False, type=str)
    parser.add_argument('-o','--output', help='output dnsmasq log file',required=False, type=str)
    parser.add_argument('-d','--domain', help='anonomous domain',required=False, type=str)
    parser.add_argument('-a','--address', help='anonomous ip address',required=False, type=str)
    parser.add_argument('-l','--log', help='create a log file',required=False, type=str)
    parser.add_argument('-v','--verbose', help='verbose logging',required=False, type=str)

    args = parser.parse_args()

    if args.log:
        fh = logging.FileHandler(args.log)
        fh.setFormatter(formatter)
        logger.addHandler(fh)
    else:
        ch = logging.StreamHandler()
        ch.setFormatter(formatter)
        logger.addHandler(ch)

    if args.verbose:
        logger.setLevel(logging.DEBUG)

    logger.debug('args<%s>', args)

    Settings.conf = vars(args)
    logger.debug('Settings<%s>', Settings.conf)

def parse_configuration_file():
    config = configparser.ConfigParser()

    if Settings.get('config') is not None:
        logger.info('Configuration file<%s>', Settings.get('config'))
        config.read(Settings.get('config'))
        logger.debug('config<%s>', config)

        # use configuration file setting only if not already overridden by a configuration parameter
        for k, v in Settings.conf.items():
            Settings.set(k, config.get('DEFAULT', k) if not v else v)

        logger.debug('Settings<%s>', Settings.conf)

    else:
        logger.info('No configuration file used')

def validate_settings():
    assert Settings.get('domain'), 'domain not set'
    assert Settings.get('address'), 'address not set'

    logger.info('validation ok')

def set_settings():
    parse_arguments()
    parse_configuration_file()

    # set defaults
    Settings.set('domain', 'example.com' if Settings.get('domain') is None else Settings.get('domain'))
    Settings.set('address', '0.0.0.0' if Settings.get('address') is None else Settings.get('address'))

    validate_settings()
    logger.info('Settings<%s>', Settings.conf)

def flush_expired_logs_to_file(log, file):
    keys = []

    # get list of keys that have timed out
    for k, v in log.items():
        if (time.time() - DNS_TIMEOUT) > v[0][-1]:
            keys.append(k)

    # flush the keys
    for k in keys:
        anonomise_output(fields_list=log[k], file=file)
        del log[k]
        logger.info('flushed<%s>', k)

def anonomise_output(fields_list, file):
    for fields in fields_list:
        # anonomise the domain
        fields[7] = Settings.get('domain')

        if fields[6] not in ALLOW_IP_ACTIONS:
            # anonomise the ip address
            fields[9] = Settings.get('address')

        print_log_line(file=file, fields=fields)

def get_input_output_files():
    # default input to stdin
    if Settings.get('input') is None:
        log_in = sys.stdin
    else:
        log_in = open(Settings.get('input'), 'r')

    # default output to stdout
    if Settings.get('output') is None:
        log_out = sys.stdout
    else:
        log_out = open(Settings.get('output'), 'a')

    return log_in, log_out

def process_log(input_file, output_file):
    logger.info('Started')
    # new logs are stored here whilst the query is being processed
    raw_log = {}

    # timer to periodically flush the raw_log (as some logs do not have a reply)
    log_flush_time = time.time()

    while True:
        line = input_file.readline()[:-1]
        if line:
            fields = line.split()

            # only process actual dns response logs, i.e. with 10 fields
            if len(fields) == FIELD_COUNT:
                id = fields[4]
                action = fields[6]
                context = fields[8]

                # add log creation time
                fields.append(int(time.time()))

                # create entry in log dictionary
                if id not in raw_log:
                    raw_log[id] = [fields]
                else:
                    value = raw_log[id]
                    value.append(fields)
                    raw_log[id] = value

                # final dns response
                if context == FINAL_RESPONSE_CONTEXT:
                    # filter the allowed responses
                    if action in END_ACTIONS:
                        anonomise_output(fields_list=raw_log[id], file=output_file)
                    else:
                        for fields in raw_log[id]:
                            print_log_line(file=output_file, fields=fields)

                    # delete reply logs
                    del raw_log[id]

            # do not process line, just print it out
            else:
                output_file.write(line + '\n')

            # flush the log immediately
            output_file.flush()
        else:
            time.sleep(1)
            if len(raw_log) > 0 and (time.time() - FLUSH_INTERVAL) > log_flush_time:
                # reset the timer
                log_flush_time = time.time()
                flush_expired_logs_to_file(log=raw_log, file=output_file)

def main():
    try:
        print('Starting ' + __file__ )

        set_settings()
        input_file, output_file = get_input_output_files()

        try:
            process_log(input_file, output_file)
        finally:
            # do not close stdin or stdout
            if input_file.name != '<stdin>':
                input_file.close()
                logger.info('closed<%s>', input_file.name)
            if output_file.name != '<stdout>':
                output_file.close()
                logger.info('closed<%s>', output_file.name)

    except KeyboardInterrupt:
        # here you put any code you want to run before the program
        # exits when you press CTRL+C
        print('You Exited')

    except SystemExit:
        # here you put any code you want to run before the program
        # exits when you press CTRL+C
        print('SystemExit')

    except:
        # this catches ALL other exceptions including errors.
        # You won't get any error messages for debugging
        # so only use it once your code is working
        print('Unexpected error:', sys.exc_info()[0])
        raise

    finally:
        print('Finally Exited')

if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        msg = 'Last Error: %s' % e
        print(msg)