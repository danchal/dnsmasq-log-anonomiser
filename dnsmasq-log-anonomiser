#!/usr/bin/python3
import os, time, sys, configparser, argparse

print('Starting ' + __file__ )

try:
    END_ACTIONS = ['cached', 'reply']
    ALLOW_IP_ACTIONS = ['query[A]', 'query[AAAA]', 'query[PTR]', 'query[SRV]', 'forwarded']
    FINAL_RESPONSE_CONTEXT = 'is'

    def print_log_line(file, fields):
        file.write('%s %s %s %s %s %s %s %s %s %s\n' % (fields[0], fields[1], fields[2], fields[3], fields[4], fields[5], fields[6], fields[7], fields[8], fields[9] ))
        return

    def get_file(argument, config, option):
        if argument:
            file_path = argument
        elif config:
            file_path = config
        else:
            file_path = sys.stdin

        file = open(file_path, option)
        return file

    parser = argparse.ArgumentParser(description='Dnsmasq log anonomiser.')
    parser.add_argument('-c','--config', help='configuration file',required=False, type=str)
    parser.add_argument('-i','--input', help='input dnsmasq log file',required=False, type=str)
    parser.add_argument('-o','--output', help='output dnsmasq log file',required=False, type=str)
    parser.add_argument('-d','--domain', help='anonomous domain',required=False, type=str)
    parser.add_argument('-a','--address', help='anonomous ip address',required=False, type=str)

    args = parser.parse_args()

    print(args)

    config = configparser.RawConfigParser()

    if args.config:
        config.read(args.config)

        print(config)

        input_file = config.get('DEFAULT', 'DnsmasqLogIn') if not args.input else args.input
        output_file = config.get('DEFAULT', 'DnsmasqLogIn') if not args.output else args.output
        anon_domain = config.get('DEFAULT', 'AnonDomain') if not args.domain else args.domain
        anon_ip = config.get('DEFAULT', 'AnonIP') if not args.address else args.address


    input_file = args.input if args.input else input_file
    output_file = args.output if args.output else output_file
    anon_domain = args.domain if args.domain else anon_domain
    anon_ip = args.address if args.address else anon_ip

    print('DnsmasqLogIn<%s>, DnsmasqLogOut<%s>, AnonDomain<%s>, AnonIP<%s>' % (input_file, output_file, anon_domain, anon_ip) )

    if not os.path.exists(input_file):
        os.mkfifo(input_file)

    log_in = get_file(args.input, input_file, 'r')
    log_out = get_file(args.output, output_file, 'a')

    # new logs are stored here whilst the query is being processed
    log_entries = {}

    while True:
        line = log_in.readline()[:-1]
        if line:
            fields = line.split()

            # only process actual dns response logs, i.e. with 10 fields
            if len(fields) == 10:
                id = fields[4]
                action = fields[6]
                context = fields[8]
                domain = fields[7]
                ip_addr = fields[9]

                # create entry in log dictionary
                if id not in log_entries:
                    log_entries[id] = [fields]
                else:
                    value = log_entries[id]
                    value.append(fields)
                    log_entries[id] = value

                # final dns response
                if context == FINAL_RESPONSE_CONTEXT:
                    # filter the allowed responses
                    if action in END_ACTIONS:
                        for fields in log_entries[id]:

                            # anonomise the domain
                            fields[7] = anon_domain

                            if fields[6] not in ALLOW_IP_ACTIONS:
                                # anonomise the ip address
                                fields[9] = anon_ip

                            print_log_line(log_out, fields)
                    else:
                        for fields in log_entries[id]:
                            print_log_line(log_out, fields)

                    # delete reply logs
                    del log_entries[id]

            # do not process line, just print it out
            else:
                log_out.write(line + '\n')

            # flush the log immediately
            log_out.flush()
        else:
            time.sleep(1)

except KeyboardInterrupt:
    # here you put any code you want to run before the program
    # exits when you press CTRL+C
    print('You Exited')

except SystemExit:
    # here you put any code you want to run before the program
    # exits when you press CTRL+C
    print('SystemExit')

except:
    # this catches ALL other exceptions including errors.
    # You won't get any error messages for debugging
    # so only use it once your code is working
    print('Unexpected error:', sys.exc_info()[0])
    raise

finally:
    log_in.close()
    log_out.close()
    print('Finally Exited')